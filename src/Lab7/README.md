### Лабораторна робота №7  
#### Тема:Колекції. Списки

Хід роботи:
1. Ознайомитись з javadoc для наступних інтерфейсів та класів:
- Collection
- List
- ArrayList
- LinkedList
- Iterator
- RandomAccess
2. Виконати завдання з таблиці 2 відповідно до свого варіанту у таблиці 1. Для цього:
- проаналізувати завдання;
- створити зазначенні класи;
- для створення списків слід використовувати класи та інтерфейси з Collection Framework
  (заборонено використовувати масиви);
- усі списки мають бути типізованими (наприклад, ArrayList&lt;Student&gt;, а не просто ArrayList);
- при реалізації задач «1)», «2)», «3)» слід застосувати наступні методи перегляду колекцій
  у відповідності до свого варіанту (табл. 1):  
  а) нетипізований ітератор;  
  b) типізований ітератор;  
  c) типізований цикл «for-each».  

3. Відповісти на контрольні питання
Варіант 20  
   Завдання 5  
   Класи:
   Сервіс пошуку товарів (список інтернет-магазинів)
   Інтернет-магазин (назва магазина, список товарів та цін на них в цьому магазині)
   Товар (назва товару, рекомендована ціна виробника)  
   Задача:
1) знайти мінімальну ціну на заданий товар
2) скласти список магазинів, в яких заданий товар можна купити по мінімальній
   ціні
3) Визначити, чи є магазин, усі товари якого можна купити по цінам, дешевшим
   ніж рекомендована ціна виробника.  

   Тип ітератора:  
   Задача 1: a  
   Задача 2: c  
   Задача 3: b  

Контрольні питання:

1. Для чого призначений Collections Framework?

Collections Framework у Java забезпечує набір класів і інтерфейсів для роботи з колекціями об’єктів. Його основні призначення:

	•	Спрощення роботи з групами даних (збірками об’єктів).
	•	Уніфікація API для різних структур даних (списки, множини, мапи тощо).
	•	Забезпечення високої продуктивності за рахунок ефективних реалізацій колекцій.
	•	Підтримка динамічного зростання та зменшення об’єму даних без явного управління пам’яттю.
	•	Надання засобів для сортування, пошуку, ітерації тощо.

2. В чому полягає різниця між масивами та колекціями?

   •	Розмір:  
   Масиви мають фіксований розмір, визначений під час створення.  
   Колекції є динамічними: вони можуть змінювати розмір у процесі виконання програми.  
   •	Типи даних:  
   Масиви підтримують лише елементи одного типу (примітивні або об’єктні).  
   Колекції підтримують лише об’єктні типи.  
   •	Функціональність:  
   Масиви мають базовий набір операцій (отримання, запис елементів).  
   Колекції надають багатий набір методів для роботи з даними: сортування, пошук, фільтрація, видалення тощо.  
   •	Структура:  
   Масиви мають послідовну структуру (індекси).  
   Колекції можуть мати складнішу структуру: списки, множини, мапи.  

3. Які особливі властивості є у списків порівняно з іншими типами колекцій?

   •	Порядок елементів: Списки зберігають порядок додавання елементів.  
   •	Доступ за індексом: Можна отримати елемент за індексом (метод get(int index)).  
   •	Повторюваність: Списки допускають дублікати, на відміну від множин.  
   •	Різноманіття реалізацій: ArrayList, LinkedList, CopyOnWriteArrayList і т. д., кожна з яких підходить для певних сценаріїв.  

4. Чим списки відрізняються від масивів?

   •	Розмір: Масиви мають фіксований розмір, а списки динамічно змінюються.  
   •	Функціональність: Списки мають більше функцій для роботи з елементами (додавання, видалення, пошук, сортування тощо).  
   •	Типи даних: Масиви можуть містити примітивні типи, списки — лише об’єктні типи.  
   •	Гнучкість: Списки є частиною Collections Framework, що забезпечує сумісність з іншими колекціями.  

5. Чим ArrayList відрізняється від LinkedList? Який з них у яких випадках краще використовувати?

   ArrayList:  
   •	Реалізований на основі масиву.  
   •	Швидкий доступ за індексом (O(1)).  
   •	Додавання в кінець списку також швидке (O(1)), але вставка або видалення елементів у середині списку повільніше (O(n)).  
   •	Використовується, коли переважає доступ до елементів за індексом.  
   	LinkedList:  
   •	Реалізований як двозв’язний список.  
   •	Повільний доступ за індексом (O(n)), оскільки потрібна ітерація.  
   •	Швидке додавання та видалення елементів у будь-якій позиції (O(1)), якщо є посилання на вузол.  
   •	Використовується, коли часто відбувається вставка або видалення елементів.  

6. Що таке Iterator? В чому полягають переваги використання ітератора у порівнянні з класичним циклом for?

   •	Iterator — це інтерфейс, який дозволяє послідовно перебирати елементи колекції без знання її внутрішньої структури.  
   •	Переваги:  
   •	Уніфікованість: Ітератор працює з будь-якою колекцією (на відміну від індексів, які не підтримуються, наприклад, у множинах).  
   •	Безпека: Підтримує fail-fast механізм — виявлення змін колекції під час ітерації.  
   •	Гнучкість: Легко можна видаляти елементи під час ітерації за допомогою iterator.remove().  

7. Що таке типізовані та нетипізовані колекції?

   Типізовані колекції (Generics):  
   •	Використовують параметри типів, наприклад, ArrayList<String>.  
   •	Забезпечують перевірку типів під час компіляції.  
   •	Зменшують кількість помилок і виключають необхідність явного приведення типів.  
   Нетипізовані колекції:  
   •	Не використовують параметри типів, наприклад, ArrayList.  
   •	Усі елементи зберігаються як об’єкти Object, і потребують приведення типів.  
   •	Використовувалися до введення Generics у Java 5.  

8. Для чого потрібен інтерфейс RandomAccess?

   •	RandomAccess — це маркерний інтерфейс, який вказує, що колекція забезпечує швидкий доступ до елементів за індексом.  
   •	Наприклад, клас ArrayList реалізує цей інтерфейс, на відміну від LinkedList.  
   •	Він корисний для оптимізації алгоритмів, які працюють з колекціями (наприклад, вибір між циклом for та ітератором).  

9. Чим Collection відрізняється від Collections?

   •	Collection — це базовий інтерфейс для всіх колекцій, таких як List, Set, Queue. Він визначає основні операції, такі як додавання, видалення, перевірка наявності елементів тощо.  
   •	Collections — це клас, що містить статичні методи для роботи з колекціями, наприклад:  
   •	Сортування (Collections.sort()).  
   •	Пошук (Collections.binarySearch()).  
   •	Створення немодифікованих або синхронізованих колекцій (Collections.unmodifiableList() або Collections.synchronizedList()).